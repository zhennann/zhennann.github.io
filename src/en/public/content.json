{"meta":{"title":"EggBorn.js","subtitle":"The Ultimate Javascript Full Stack Framework","description":"The Ultimate Javascript Full Stack Framework","author":"zhennann","url":"http://egg-born.org/en"},"pages":[],"posts":[{"title":"EggBorn.js Development Guide","slug":"tutorial","date":"2017-10-17T10:18:14.000Z","updated":"2017-11-04T02:26:19.000Z","comments":true,"path":"docs/tutorial/","link":"","permalink":"http://egg-born.org/en/docs/tutorial/","excerpt":"","text":"What is the EggBorn.js? EggBorn.js is the Ultimate Javascript Full Stack Framework. EggBorn.js is a best practice for implementing full stack with Javascript.EggBorn.js does not ‘Reinvent the Wheel’, but uses the latest open source technology, so as to achieve the best combination of the full stack development technology.EggBorn.js前端采用Vue.js + Framework7 / Vue Router + Webpack，后端采用Koa.js + Egg.js，数据库采用mysql。The frontend of EggBorn.js uses Vue.js + Framework 7 / Vue Router + Webpck, while the backend uses Koa.js + Egg.js, and the Database uses mysql.EggBorn.js keeps track of the latest achievements in open source technology, and continues to optimize to keep the entire framework in the best status. EggBorn.js Focus on: Business ModularizationWith the developing of the javascript technology, the experience of the frontend and backend development becomes smoother, and the development efficiency enhance significantly. However, some friends still doubt whether it can be competent for the development of large-scale web applications. Large-scale web applications are characterized by the need to develop a large number of page components as business grows. Faced with this situation, generally there are two solutions: 1 Build as a single page application: The disadvantage is that the deployment package is very large.2 All page components are loaded asynchronously: The disadvantage is that the pages are too scattered, so the frontend should interact with the backend frequently. EggBorn.js implements the third solution: 3 The page components are classified by business requirements, which is business modularization, and implements the business module’s asynchronous loading mechanism. Thus it makes up the shortcomings of the first two solutions and satisfies the needs of the large-scale web application. EggBorn.js Technical Features Business Modularization: The page components are arranged as modules. Loading Flexibility: Modules can be loaded asynchronously or simultaneously. Highly Modular Cohesion: The module includes frontend page components and backend business logic. Parameter Configuration Flexibility: Both frontend and backend of the module can be configured separately. Internationalization：Both frontend and backend of the module support internationalization independently. Module Isolation: Module’s pages, data, logic, routing, configuration and other elements have been through namespace isolation processing, which avoids the variable pollutions and conflicts. Easy Transaction Processing: Just configuring a parameter on the routing record can process the database transaction perfectly. Progressive development: Due to the high degree of cohesion of the module, EggBorn.js can deposit the business in the form of module, which can be reused in multiple projects. Business modules can be contributed to the npm Open Source Community, and can also be deployed to the company’s internal private npm registry. With EggBorn.js, not only the components can be reused, but also the business modules do in the future. Getting StartedInstallation1$ npm install -g egg-born Create a project123$ egg-born project_name$ cd project_name$ npm install Currently EggBorn.js offers two project scaffolds: front-backend-mysql – full stack project template front – frontend-only project template Configure mysql如果采用了front-backend-mysql模板，请配置mysql连接参数（空数据库即可）If you choose the front-backend-mysql template, please configure mysql connection parameters. (empty database just does well) Edit file: src/backend/config/config.default.js12345678910111213// mysqlconfig.mysql = &#123; clients: &#123; // donot change the name __ebdb: &#123; host: '127.0.0.1', port: '3306', user: 'travis', password: '', database: 'egg-born', &#125;, &#125;,&#125;; RunStart backend service1$ npm run dev:backend Start frontend service1$ npm run dev:front EggBorn.js’s Structure DiagramSystem Structure Project Files Structure Template Files Structure Module DevelopmentNaming ConventionIn order to increase the business modules continuously and achieve a highly reusable effect, the namespace of all modules must be fully isolated, to avoid mutual pollution and conflict. Thus the naming convention is as follows: egg-born-module-{providerId}-{moduleName} Such as the module egg-born-module-a-version, the naming information is as follows: providerId: a moduleName: version fullName: egg-born-module-a-version relativeName: a-version frontend page route url: /a/version/{page} backend api route url: /a/version/{controller}/{action} Loading MechanismThe module supports both asynchronous loading and synchronous loading. Generally, the default is asynchronous loading. If you want to change it into synchronous loading, just add -sync suffix behind the module name, such as the module egg-born-module-aa-login-sync. Create a moduleGoto pathsrc/module, run the scaffolding to create the module files skeleton.1$ egg-born module_relative_name At present, EggBorn.js offers two module scaffolds: module – full stack module template module-front – frontend-only module template Module Frontend DevelopmentFrontend Page RouteIn the front/src/routes.js file, add the page route, such as123456789function load(name) &#123; return require(`./pages/$&#123;name&#125;.vue`).default;&#125;export default [ &#123; path: 'welcome/:who', component: load('welcome') &#125;, &#123; path: 'profile', component: load('profile'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: '/login', component: load('login') &#125;,]; path: supports parameters. If the path starts with /, represent the root page component. login page component is usually configured with / component: page component meta: route metadata meta.requiresAuth: If the page component needs to be logged in, it should be set to true If you reference the page component in the page, please use the absolute path, such as12&lt;f7-list-item link=\"/aa/hello/welcome/You\" title=\"Welcome\"&gt;&lt;/f7-list-item&gt;&lt;f7-list-item link=\"/aa/hello/profile\" title=\"Profile\"&gt;&lt;/f7-list-item&gt; Frontend State ManagementVuex is a state management library, which is developed specifically for Vue.js applications. EggBorn.js uses Vuex to implement a fully isolated module state management mechanism.In the front/src/store.js file, add the state, such as123456789export default function(Vue) &#123; return &#123; state: &#123; message: 'hello world', &#125;, &#125;;&#125; Access the state of the same module in the page component:1const message = this.$local.state.message; Access the state of the other module in the page component:1const message = this.$store.state[providerId][moduleName].message; For more information, see Vuex Frontend Parameters ConfigurationIn the front/src/config/config.js file, add the configuration information, such as123export default &#123; mode: 1,&#125;; Access the config of the same module in the page component:1const mode = this.$config.mode; Frontend I18NIn the directory front/src/config/locale, add the i18n file, such as zh-cn.js1234export default &#123; mode: '模式', \"Hello world! I'm %s.\": '您好，世界！我是%s。', &#125;; I18N resources can be merged globally merger, so as to share i18n resources through all the modules.Access the i18n resources in the page component:12const mode = this.$text('mode');const message = this.$text(\"Hello world! I'm %s.\",'zhennann'); Module Backend DevelopmentBackend API RouteIn the backend/src/routes.js file, add the api route, such as12345const home = require('./controller/home.js');module.exports = [ &#123; method: 'get', path: 'home/index', controller: home, action: 'index', transaction: true &#125;,]; method: get/post etc. path: Supports parameters component: Controller Component action: Controller Action. If not set, will use the last word behind path automatically. transaction: Default is false. If set to true, the database transaction will be enabled. Access the api route of the same module in the frontend page component:123this.$api.get('home/index').then(data =&gt; &#123;&#125;).catch(err =&gt; &#123;&#125;); Access the api route of the other module in the frontend page component:123this.$api.get('/providerId/moduleName/home/index').then(data =&gt; &#123;&#125;).catch(err =&gt; &#123;&#125;); Backend ControllerThe backend controller is consistent with Egg.js1234567891011module.exports = app =&gt; &#123; class HomeController extends app.Controller &#123; async index() &#123; const message = await this.service.home.index(); this.ctx.success(message); &#125; &#125; return HomeController;&#125;; For more information，see Egg.js Controller Backend ServiceService is used to encapsulate the business logic. It is consistent with Egg.js123456789101112module.exports = app =&gt; &#123; class Home extends app.Service &#123; async index() &#123; const res = await this.ctx.db.queryOne('show tables'); return res; &#125; &#125; return Home;&#125;; Different from Service of Egg.js, Service of EggBorn.js uses ctx.db to manipulate the database, which automatically supports database transaction. For more information，see Egg.js Service Backend Controller InteroperabilityFor the development of large-scale web application, EggBorn.js supports interoperability between the backend controllers, such as12345678910111213const message = await this.ctx.performAction(&#123; method: 'get', url: 'home/index', query: &#123; username: 'kevin', &#125;, params: &#123; mode: 1, &#125;, body: &#123; content: 'ready', &#125;,&#125;); method: get/post etc. url: If access backend controller of the same module, please use the relative path. If access backend contrller of the other module, please use the absolute path with the beginning of / query、params、body: Same as Egg.js Controller Backend Database OperationThe backend database operation is consistent with Egg.js For more information，see Egg.js MySQL Backend Database TransactionEggBorn.js offers a more convenient database transaction processing. You just need to configure the transaction parameter in the backend api route. Service uses ctx.db to operate database.If the controller caller call the controller callee through ctx.performAction, the database transaction status is as follow: Controller Caller Config Controller Callee Config Controller Callee Status true true true true false true false true true false false false Backend Parameters ConfigurationIn the backend/src/config/config.js file, add the configuration information, such as1234567module.exports = appInfo =&gt; &#123; const config = &#123;&#125;; config.message = \"Hello world! I'm %s.\"; return config;&#125;; 访问本模块内部的参数配置示例如下Access the config of the same module:1const message = this.ctx.config.message; Backend I18NIn the directory backend/src/config/locale, add the i18n file, such as zh-cn.js1234module.exports = &#123; \"Hello world! I'm %s.\": '您好，世界！我是%s。', 'not found': '未发现',&#125;; I18N resources can be merged globally merger, so as to share i18n resources through all the modules.Access the i18n resources:12const notFound = this.ctx.text('not found');const message = this.ctx.text(\"Hello world! I'm %s.\", 'zhennann'); Backend Error HandingIn the backend/src/config/errors.js file, add the error code1234// error code should start from 1001module.exports = &#123; 1001: 'not found',&#125;; Return error object:1this.ctx.fail(1001); Throw error exception:1this.ctx.throw(1001); Module ManagementModule DependenciesEggBorn.js通过package.json文件管理模块依赖关系。比如，模块aa-module1依赖aa-module2，需要在模块aa-module1的package.json文件中作如下配置EggBorn.js manages module dependencies through package.json file.For example, module aa-module1 depends on aa-module2, and the following configuration is needed in the package.json file of the module aa-module1123456789101112&#123; \"name\": \"egg-born-module-aa-module1\", \"version\": \"0.0.1\", \"eggBornModule\": &#123; \"dependencies\": &#123; \"aa-module2\": \"0.0.1\" &#125; &#125;, \"dependencies\": &#123; \"egg-born-module-aa-module2\": \"^0.0.1\" &#125;&#125; 设置&quot;egg-born-module-aa-module2&quot;: &quot;^0.0.1&quot;，是为了在安装模块aa-module1时自动安装模块aa-module2。如果模块没有公开发布，就不必设置。In order to automatically install the module aa-module2 when installing module aa-module1, set &quot;egg-born-module-aa-module2&quot;: &quot;^0.0.1&quot;If the module is not publicly available, there is no need to set it. Module Data VersionGenerally Modules should operate the database. The database structure is also possible to change when the module version upgrade. EggBorn.js manage the module data version so as to facilitate the accumulation of business modules. In the package.json file of the module, configure fileVersion as the current data version of the module1234567&#123; \"name\": \"egg-born-module-aa-module1\", \"version\": \"0.0.1\", \"eggBornModule\": &#123; \"fileVersion\": 1 &#125;&#125; Add backend api route:1&#123; method: 'post', path: 'version/update', controller: version &#125; Add backend controller:1234567891011module.exports = app =&gt; &#123; class VersionController extends app.Controller &#123; async update() &#123; await this.service.version.update(this.ctx.getInt('version')); this.ctx.success(); &#125; &#125; return VersionController;&#125;; Add backend service:1234567891011121314module.exports = app =&gt; &#123; class Version extends app.Service &#123; async update(version) &#123; if (version === 1) &#123; // do something &#125; &#125; &#125; return Version;&#125;; 当启动后端服务时，EggBorn.js自动检测模块数据版本的变化，并执行相应的路由，完成数据的版本升级。When the project started, EggBorn.js detects the change of the module data version automatically, and executes the corresponding api route to upgrade the data version. Module PublishWhen the module code in the project is stable, you can publish the module publicly and contribute to the Open Source Community. You can also create npm private registry in your company, and then publish the modules to the private registry, so as to form company assets for easy reuse. 12345$ cd path/to/module -- Goto the module directory$ npm install -- Install module dependencies$ npm run build:front -- Build frontend$ npm run build:backend -- Build backend$ npm publish -- Publish to npm registry Test DriveOnly backend test drive is supported currently. Backend Controller TestIn the directory backend/test/controller, add controller test file123456789101112131415// controller/home.test.jsconst &#123; app, mock, assert &#125; = require('egg-mock/bootstrap');const parseMockUrl = function(url) &#123; const prefix = app.mockUtil.parseUrlFromPackage(__dirname); return `$&#123;prefix&#125;$&#123;url&#125;`;&#125;;describe('test/controller/home.test.js', () =&gt; &#123; it('action:index', async () =&gt; &#123; const result = await app.httpRequest().get(parseMockUrl('home/index')); assert(result.body.code === 0); &#125;);&#125;); Backend Service TestIn the directory backend/test/service, add service test file123456789101112131415// service/home.test.jsconst &#123; app, mock, assert &#125; = require('egg-mock/bootstrap');const parseMockUrl = function() &#123; return app.mockUtil.parseUrlFromPackage(__dirname);&#125;;describe('test/service/home.test.js', () =&gt; &#123; it('index', async () =&gt; &#123; const ctx = app.mockContext(&#123; mockUrl: parseMockUrl() &#125;); const message = await ctx.service.home.index(); assert(message); &#125;);&#125;); Run TestRun test in the project root directory12$ npm run test:backend$ npm run cov:backend Frontend Framework ConfigurationFrontend BootstrapFrontend provides two bootstraps Vue.js + Framework7 Vue.js + Vue Router Framework7 is a mobile UI liabrary with built-in route mechanism.Vue Router is the official routing library for Vue.js. Vue Router can be used with other various UI libraries. Switch in the file src/front/main.js12345678910// choose one// framework7import main from './framework7/main.js';// vuerouter// import main from './vuerouter/main.js';// exportexport default main; Frontend Parameters ConfigurationThe parameters of the file src/front/config/config.js can override the parameters of the modules1234567export default&#123; module: &#123; 'aa-hello': &#123; mode: 2, &#125;, &#125;,&#125;; Frontend I18NFramework i18n resources can override the modules’s ones.In the directory src/front/config/locale, add the i18n file, such as zh-cn.js123export default &#123; mode: '模式',&#125;; Backend Framework ConfigurationBackend FrameworkEggBorn.js backend framework is based on Egg.js，so supports all of the features provided by Egg.js For more information，see Egg.js Backend Parameters ConfigurationThe parameters of the file src/backend/config/config.default.js can override the parameters of the modules.123456789101112module.exports = appInfo =&gt; &#123; const config = &#123;&#125;; // module config config.module = &#123; 'aa-hello': &#123; mode: 2, &#125;, &#125;; return config;&#125;; Backend I18NFramework i18n resources can override the modules’s ones.In the directory src/backend/config/locale, add the i18n file, such as zh-cn.js123module.exports = &#123; mode: '模式',&#125;; Project DeploymentBuild Frontend1$ npm run build:front Start Backend1$ npm run start:backend Stop Backend1$ npm run stop:backend Backend Start ParametersEdit the file build/config.js12345// backendconst backend = &#123; port: 7002, hostname: '127.0.0.1',&#125;; Nginx ConfigurationSuggest to use Nginx hosting frontend static resources and reverse proxy backend service1234567891011121314151617181920server &#123; listen 80; server_name example.com www.example.com; set $node_port 7002; root /path/to/www; location /api/ &#123; proxy_http_version 1.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_pass http://127.0.0.1:$node_port$request_uri; proxy_redirect off; &#125;&#125; GitHub Contribution Any questions, welcome to submit issue, or fork and submit PR!","categories":[{"name":"docs","slug":"docs","permalink":"http://egg-born.org/en/categories/docs/"}],"tags":[]},{"title":"EggBorn.js Development Guide","slug":"tutorial_en","date":"2017-10-17T10:18:14.000Z","updated":"2017-11-04T02:22:32.000Z","comments":true,"path":"docs/tutorial_en/","link":"","permalink":"http://egg-born.org/en/docs/tutorial_en/","excerpt":"","text":"What is the EggBorn.js? EggBorn.js is a top-level, Javascript full stark developing framework. EggBorn.js is a best practice for implementing full stark with Javascript.EggBorn.js does not ‘Reinvent the Wheel’, but uses the latest technology - Open Source, which is the best combination of the Full Stark development.The front-end of EggBorn.js uses Vue.js and Framework 7 / Vue Router and Webpck, while the back-end uses Koa.js and Egg.js. The Database uses mysql.EggBorn.js keeps track of the latest achivevments in Open Source Technology and continues to optimize to keep the entire framework in the best status. EggBorn.js Focus on: Business ModularizationWith the developing of the Javascript technology, the experience of the front-end and back-end development becomes smoother and the development efficiency enhance significantly. However, some net friends still doubt whether it can be competent for the development of large-scale Web applications. Large-scale applications are characterized by the need to develop a large number of page components as business grows. Faced with this situation, generally there are two solutions: 1 Using single-page construction. The disadvantage is producing a large deposition package.2 Using page asynchronous loading. The disadvantage is that the pages are too fragmented, which need to interact with the back-end frequently. EggBorn.js implements a third solution: 3 The page components are classified by business requirements, which is business modularization and implements the module’s asynchronous loading mechanism. Thus it makes up the shortcomings of the first two solutions and satisfies the needs of the large-scale Web application business. EggBorn.js Technical Feature Business Modularization: The page components are arranged by module. Loading Flexibility: Modules can be loaded asynchronously or simultaneously. Highly Modular Cohesion: The module includes front-end page components and back-end business logic. Parameter Configuration flexibility: Both front-end and back-end of the module can be configured separately. Internationalization：Both front-end and back-end of the module support internationalization independently. Module Isolation: Module’s pages, data, logic, routing, configuration and other elements have been through namespace isolation processing, which avoids the variable pollutions and conflicts. Easy Transaction Processing: Just configuring a parameter on the routing record can finish the transaction of the database perfectly. Progressive development: Due to the high degree of cohesion of the module, EggBorn.js can deposit the business in the form of module, which can be reused in multiple projects. It can be contributed to the npm Open Source Community and can also be deployed to the conpans’s internal private npm warehouse. With EggBorn.js, both components and business modules can be reused in the future. Easy to Pick upInstall EggBorn.js Scaffold1$ npm i -g egg-born Build New Project1$ egg-born project_name Currently EggBorn.js offers two project scaffolds, respectively front-backend-mysql – Front-end and back-end project templates with full stack. front – Front-end project templates, while back-end uses other programs. Configure mysql Connection ParameterIf you use the ‘front-backend-mysql’ template, please configure the mysql connection parameters (Just an empty database). Edit file src/backend/config/config.default.js.12345678910111213// mysqlconfig.mysql = &#123; clients: &#123; // donot change the name __ebdb: &#123; host: '127.0.0.1', port: '3306', user: 'travis', password: '', database: 'egg-born', &#125;, &#125;,&#125;; Run the Project1234$ cd path/to/project$ npm i$ npm run dev:backend -- Start back-end service.$ npm run dev:front -- Start front-end service. EggBorn.js’s Structure DiagramSystem Structure Project File Structure Template File Structure Front-end DevelopmentStart the FileFront-end structure offers two projects Vue.js + Framework7 Vue.js + Vue Router Framework 7 is a mobile development, exclusive UI interface library with built-in route mechanism.Vue Router is the official routing library of Vue.js. Vue Router can be used with other various UI interface library. Switch in the file src/front/main.js12345678910// choose one// framework7import main from './framework7/main.js';// vuerouter// import main from './vuerouter/main.js';// exportexport default main; Configure the FileThe configuration parameters of the file src/front/config/config.js can cover the parameter of the templates.1234567export default&#123; module: &#123; 'aa-hello': &#123; mode: 2, &#125;, &#125;,&#125;; InternationalizationAdd an international file to the src/front/config/locale file directory to overwrite the module’s international language.Example of language definitions in the zh-cn.js are as follow.123export default &#123; mode: '模式',&#125;; Back-end DevelopmentBack-end StructureThe back-end structure is based on Egg.js and supports all the function and features provided by Egg.js fully. For more information, please refer to: Egg.js Configuration FileIn the file src/backend/config/config.default.js,the parameter configuration can overwrite the parameters of the module.123456789101112module.exports = appInfo =&gt; &#123; const config = &#123;&#125;; // module config config.module = &#123; 'aa-hello': &#123; mode: 2, &#125;, &#125;; return config;&#125;; InternationalizationIf you add the international file to src/backend/config/locale file directory,it can overright the module’s international language.In the file zh-cn.js, the defination of the language is as follow:123export default &#123; mode: '模式',&#125;; Module DevelopmentNaming ConventionIn order to increase the business module continuously and achieve a highly reusable effect, the namespace of all modules must be fully isolated, to avoid mutual pollution and conflict. Thus the naming convention is as follows: egg-born-module-{providerId}-{moduleName} Such as the module egg-born-module-a-version, the naming information is as follows: providerId: a moduleName: version fullName: egg-born-module-a-version relativeName: a-version Front-end page route address: /a/version/{page} Back-end API route address：/a/version/{controller}/{action} Loading MechanismThe module supports both asynchronous loading and synchronous loading. Generally, the default is asynchronous loading. If you want to change it into synchronous loading, just add ‘-sync’ suffix behind the module name.Such as the module egg-born-module-aa-login-sync. Build New ModuleExecute the Scaffolding in the src/module file directory and create the module file skeleton.1$ egg-born module_relative_name At present, EggBorn.js offers two Module Scaffolds, respectively module – Full Stack Module Template module-front – Front-end Module Template Front-end Development in the ModuleFront-end Page RouteIn the front/src/routes.js file, add the page route, such as123456789function load(name) &#123; return require(`./pages/$&#123;name&#125;.vue`).default;&#125;export default [ &#123; path: 'welcome/:who', component: load('welcome') &#125;, &#123; path: 'profile', component: load('profile'), meta: &#123; requiresAuth: true &#125; &#125;, &#123; path: '/login', component: load('login') &#125;,]; path: Path, supports the parameter. If the path starts with /, represent the root page component. The page component is usually configured with login. component: Page component object. meta: Route metadata meta.requiresAuth: If the page component needs to be logged in, it must be set to true If you reference the page component in the page, please use the absolute path, such as:12&lt;f7-list-item link=\"/aa/hello/welcome/You\" title=\"Welcome\"&gt;&lt;/f7-list-item&gt;&lt;f7-list-item link=\"/aa/hello/profile\" title=\"Profile\"&gt;&lt;/f7-list-item&gt; Front-end State ManagementVuex is a state management model developed specifically for Vue.js applications. EggBorn.js uses Vuex to implement a fully isolated module state management mechanism.In the front/src/store.js file, add the state, such as123456789export default function(Vue) &#123; return &#123; state: &#123; message: 'hello world', &#125;, &#125;;&#125; Visit the own state of the module in the page component:1const message = this.$local.state.message; Visit the other state of the module in the page component:1const message = this.$store.state[providerId][moduleName].message; For more information, please refer to Vuex Front-end parameter configurationIn the front/src/config/config.js file, add the configuration information, such as123export default &#123; mode: 1,&#125;; EggBorn.js only supports the configuration of the parameters inside the module in the page component.1const mode = this.$config.mode; Front-end InternationalizationIn the front/src/config/locale file directory, add the internationalization fileThe definitions of language in the zh-cn.js file are as follow.1234export default &#123; mode: '模式', \"Hello world! I'm %s.\": '您好，世界！我是%s。', &#125;; International language takes a global merger, which is conducive to the share of language resources. The way to visit the page component is as follow.12const mode = this.$text('mode');const message = this.$text(\"Hello world! I'm %s.\",'zhennann'); Back-end Development in the ModuleBack-end api RouteIn the backend/src/routes.js file, add the page route, such as12345const home = require('./controller/home.js');module.exports = [ &#123; method: 'get', path: 'home/index', controller: home, action: 'index', transaction: true &#125;,]; method: get/post etc. path: Path, supports the parameter. component: Controller object. action: Controller method. If it is not set, back-end api route will use the word behind ‘path’ automatically. transaction: The default is false. If it is set to true, the database transaction will be enabled. Visit the own module api route in the front-end page component.123this.$api.get('home/index').then(data =&gt; &#123;&#125;).catch(err =&gt; &#123;&#125;); Visit the other module api route in the front-end page component.123this.$api.get('/providerId/moduleName/home/index').then(data =&gt; &#123;&#125;).catch(err =&gt; &#123;&#125;); Back-end ControllerThe achievement of the back-end Controller is consistent with Egg.js.1234567891011module.exports = app =&gt; &#123; class HomeController extends app.Controller &#123; async index() &#123; const message = await this.service.home.index(); this.ctx.success(message); &#125; &#125; return HomeController;&#125;; For more information, please refer to Egg.js Controller Back-end ServiceService is used to encapsulate the business logic for the Controller debugging. Its implementation is consistent with Egg.js.123456789101112module.exports = app =&gt; &#123; class Home extends app.Service &#123; async index() &#123; const res = await this.ctx.db.queryOne('show tables'); return res; &#125; &#125; return Home;&#125;; The difference between Egg.js and Back-end Service, Service uses ctx.db to manipulate the database, which automatically supports database transactions. For more information, please refer to Egg.js Service Back-end Controller TransferabilityEggBorn.js supports transferability between the module of Back-end Controller, to support the development of large Web systems, such as12345678910111213const message = await this.ctx.performAction(&#123; method: 'get', url: 'home/index', query: &#123; username: 'kevin', &#125;, params: &#123; mode: 1, &#125;, body: &#123; content: 'ready', &#125;,&#125;); method: get/post etc. url: If you visit Controller of the own module, please use the relative path. If you visit Contrller of the other module, please use the absolute path with the beginning of /. query、params、body: Keep consistency with the conventional Controller’s parameters. Back-end Database OperationThe back-end database operation keeps consistency with Egg.js. For more information, please refer to Egg.js MySQL Back-end Database TransactionEggBorn.js offers a more convenient database transaction achievement way. You only need to configure the transaction parameters in the back-end api routing record. Service uses ctx.db to operate database.If the master Controller debugs the child Controller through ctx.performAction, the database transaction opening rule is as follow： Main Controller Configuration Sub Controller Configuration Sub Controller practical Starting true true true true false true false true true false false false Back-end Parameter ConfigurationIn the backend/src/config/config.js file, add the configuration information, such as1234567module.exports = appInfo =&gt; &#123; const config = &#123;&#125;; config.message = \"Hello world! I'm %s.\"; return config;&#125;; An example of parameter configuration is available to visit the module.1const message = this.ctx.config.message; Back-end Error HandingIn the backend/src/config/locale file directory, add the international file.The language definition in zh-cn.js file is as follow.1234module.exports = &#123; \"Hello world! I'm %s.\": '您好，世界！我是%s。', 'not found': '未发现',&#125;; International language takes a global merger, which is conducive to the share of language resources. The visit way is as follow.12const notFound = this.ctx.text('not found');const message = this.ctx.text(\"Hello world! I'm %s.\", 'zhennann'); Back-end Error HandingIn the backend/src/config/errors.js file, add the error code.1234// error code should start from 1001module.exports = &#123; 1001: 'not found',&#125;; The example of returning error information is as follow.1this.ctx.fail(1001); The example of throwing exception is as follow.1this.ctx.throw(1001); Module ManagementModule DependencyEggBorn.js manages module dependencies through package.json file.For example, module aa-module1 depends on aa-module2, and the following configuration is needed in the package.json file of the module aa-module1.123456789101112&#123; \"name\": \"egg-born-module-aa-module1\", \"version\": \"0.0.1\", \"eggBornModule\": &#123; \"dependencies\": &#123; \"aa-module2\": \"0.0.1\" &#125; &#125;, \"dependencies\": &#123; \"egg-born-module-aa-module2\": \"^0.0.1\" &#125;&#125; In order to automatically install the module aa-module2 when installing module aa-module1, set &quot;egg-born-module-aa-module2&quot;: &quot;^0.0.1&quot;If the module is not publicly available, there is no need to set it. Module Data VersionGenerally Modules are required to operate the database. The database structure is also possible to change when the template version upgrade. EggBorn.js achieves the management of the module data version and facilitates the accumulation of business modules. In the package.json file of the module, Configure fileVersion as the current data version.1234567&#123; \"name\": \"egg-born-module-aa-module1\", \"version\": \"0.0.1\", \"eggBornModule\": &#123; \"fileVersion\": 1 &#125;&#125; Add Api routing at the back-end of the module.1&#123; method: 'post', path: 'version/update', controller: version &#125; Add version Controller1234567891011module.exports = app =&gt; &#123; class VersionController extends app.Controller &#123; async update() &#123; await this.service.version.update(this.ctx.getInt('version')); this.ctx.success(); &#125; &#125; return VersionController;&#125;; Add version Service1234567891011121314module.exports = app =&gt; &#123; class Version extends app.Service &#123; async update(version) &#123; if (version === 1) &#123; // do something &#125; &#125; &#125; return Version;&#125;; When you start the back-end service, EggBorn.js detects the change of the module data version automatically and executes the corresponding route to complete the version of the data upgrade. Module ReleaseWhen the module code in the project is stable, you can publish the module publicly and contribute to the Open Source Community. You can also create npm private warehouses in your company and then publish the modules to private warehouses to form company assets for easy reuse.The module is released as follow.12345$ cd path/to/module -- Go to the module directory$ npm i -- Install module dependency$ npm run build:front -- Build front-end code$ npm run build:backend -- Build back-end code$ npm publish -- Post to npm warehouse Test DriveOnly back-end test drivers are supported currently. Back-end Controller TestIn the backend/test/controller file directory ,add Controller test file.123456789101112131415// controller/home.test.jsconst &#123; app, mock, assert &#125; = require('egg-mock/bootstrap');const parseMockUrl = function(url) &#123; const prefix = app.mockUtil.parseUrlFromPackage(__dirname); return `$&#123;prefix&#125;$&#123;url&#125;`;&#125;;describe('test/controller/home.test.js', () =&gt; &#123; it('action:index', async () =&gt; &#123; const result = await app.httpRequest().get(parseMockUrl('home/index')); assert(result.body.code === 0); &#125;);&#125;); Back-end Service TestIn the backend/test/service file directory, add Service Test file.123456789101112131415// service/home.test.jsconst &#123; app, mock, assert &#125; = require('egg-mock/bootstrap');const parseMockUrl = function() &#123; return app.mockUtil.parseUrlFromPackage(__dirname);&#125;;describe('test/service/home.test.js', () =&gt; &#123; it('index', async () =&gt; &#123; const ctx = app.mockContext(&#123; mockUrl: parseMockUrl() &#125;); const message = await ctx.service.home.index(); assert(message); &#125;);&#125;); Execute TestExecute the test in the project root directory.12$ npm run test:backend$ npm run cov:backend DeploymentBuild Front-end Code1$ npm run build:front Start Back-end Service1$ npm run start:backend Stop Back-end Service1$ npm run stop:backend Back-end Service Startup Parameter ConfigurationEdit build/config.js file.12345// backendconst backend = &#123; port: 7002, hostname: '127.0.0.1',&#125;; nginx ConfigurationWe suggest you use nginx hosting front-end static resources and reverse proxy backend services. The configuration is as follow.1234567891011121314151617181920server &#123; listen 80; server_name example.com www.example.com; set $node_port 7002; root /path/to/www; location /api/ &#123; proxy_http_version 1.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_pass http://127.0.0.1:$node_port$request_uri; proxy_redirect off; &#125;&#125; GitHub Contribution If there are any questions, you are welcome to submit issue，or directly modify the submission PR！","categories":[{"name":"docs","slug":"docs","permalink":"http://egg-born.org/en/categories/docs/"}],"tags":[]}]}